//функция поиска главного окна любого созданного процесса в системе
//функция work в Windows 2000/ME or later
HWND afc::wnd::GetProcessMainFrame(DWORD dwProcessId)
{
    //идея такова:
    //1. Перечисляем потоки созданные в контескте заданного процесса
    //2. По моему скромному мнению нам достаточно взять первый элемент так называемого
    //   снимка, потому что это будет mainthread, а mainframe процесса обычно в нем и создается
    //3. Перечисляем окна принадлежащие потоку, берем первое к нам попавшее и учитывая иерархию
    //   и идя по ней находим так называемый mainframe, он же owner всего представления
    
    //возможный дескриптор искомого нами окна - possible target
    HWND hWnd = 0;
    
    //получаем дескриптор процесса для определения его статуса
    HANDLE hProcess = ::OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);
    //если конечно же небыло препятствий на этапе определения дескриптора
    //либо существования процесса описываемого парадаваемым нам идентификатором
    if(hProcess)
    {
        //код завершения процесса - начальное значение выбрано только
        //из соображений несовпадения с контрольным значением
        DWORD lpExitCode = STILL_ACTIVE + 1;
        //минимально необходимые и достаточные условия для оперделения запрошенных параметров
        //а в переводе на русский язык - смысл искать mainframe есть только если процесс активен
        if(::GetExitCodeProcess(hProcess, &lpExitCode))/*->*/if(lpExitCode == STILL_ACTIVE)
        {
            //делаем снимок информации о всех потоках созданных процессами
            //в контексте десктопа и получаем дескриптор для дальнейшего
            //использования полученной информации в памяти
            HANDLE hThreadSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwProcessId);//WinXX кроме NT40 или младше
            //если дескриптор описывает существующий снимок
            if(hThreadSnap != INVALID_HANDLE_VALUE)
            {
                //структура которая будет содержать информацию о каждом
                //перечисляемом потоке - описание приведено в МСДН
                THREADENTRY32 th32 = {0};    
                
                //размер структуры в байтах. Общий смысл в том, что тот кто
                //будет использовать эту структуру должен знать о ее фактическом размере
                th32.dwSize = sizeof(THREADENTRY32);
                
                //заполнение структуры информацией
                //о первом потоке содержащемся в списке
                if(::Thread32First(hThreadSnap, &th32))//WinXX кроме NT40 или младше 
                { 
                    do 
                    {
                        //это обуславливает то, что нас интересуют только
                        //потоки созданные заданным процессом
                        if(th32.th32OwnerProcessID == dwProcessId)
                        {
                            //ожидание окончания инициализации процесса для нахождения дескриптора его главного
                            //окна по русски говоря учитывая асинхронный вариант вызова данной функции мы 
                            //можем нарваться на ситуацию, когда мы попытаемся найти то, что еще не создано
                            ::WaitForInputIdle(hProcess, INFINITE);
                            //перечисление окон относящихся к потоку th32.th32ThreadID
                            //в данном случае возврат будет TRUE, если ничего не будет найдено
                            //таковы свойства CALLBACK function вызываемой при перечислении
                            //и FALSE, если мы найдем все таки хоть одно окно созданное любым
                            //из потоков процесса - на этом можно уже и закончить
                            if(!::EnumThreadWindows(th32.th32ThreadID, afc::wnd::GetMainFrameProc, (LPARAM)(&hWnd))) break;
                        }//if(th32.th32OwnerProcessID == dwProcessId)
                    }//do
                    //пока продолжается список - Snapshot
                    while(::Thread32Next(hThreadSnap, &th32));//WinXX кроме NT40 или младше 
                }//if(Thread32First(hThreadSnap, &th32))
                //закроем дескриптор уже не используемого
                //нами в дальнейшем объекта
                ::CloseHandle(hThreadSnap);
            }//if(hModuleSnap != INVALID_HANDLE_VALUE)
        }//if(lpExitCode == STILL_ACTIVE)
        //поступим по человечески и закроем дескриптор уже использованного
        //объекта чтобы он не висел на нас до конца работы приложения
        //так можно сделать только потому что процесс является объектом ядра
        ::CloseHandle(hProcess);
    }//if(hProcess)
    
    //дескриптор главного окна процесса
    //заданного идентификатором
    return hWnd;
}

//так называемая функция обратного вызова, которая будет вызываться функцией API интерфейса
//EnumThreadWindows при перечислении всех окон первого порядка с передачей в нее параметров
//характеризующих каждое окно, которым владеет поток заданный с помощью ID
//в данном конкретном случае она оптимизирована для нахождения так называемого фрейма заданного процесса
//а найдем мы таким образом именно фрейм, потому что для нахождения главного окна всей
//всей иерархии мы используем ID именно the primary thread of the newly created process.
BOOL CALLBACK afc::wnd::GetMainFrameProc(HWND hwnd, LPARAM lParam)
{
    //вся эта катавасия нужна еще и потому что, фрейм может иметь еще и дочерние окна
    //и первым при такой модели поиска мы можем поймать не обязательно ROOT и поэтому
    //пройдемся на всякий случай по всей цепи и таким образом несколько универсализируем поиск
    
    //нам нужна иерархия только видимых окон
    //ганяться за тенью мы пожалуй не будем
    if(::IsWindowVisible(hwnd))
    {
        //в первый раз пускают всех и без всяких условий
        do
        {
            //проверка - действительно ли дескриптор валидного окна
            //копирование значения валидного дескриптора по заданному адресу
            if(::IsWindow(hwnd)) ::memcpy((void*)lParam, (void*)&hwnd, sizeof(HWND));
            
            //получение значения стилей окна для того чтобы знать в каком направлении двигаться
            //чтобы найти необходимое нам окно, так как пока мы знаем только то, что найденное
            //окно принадлежит текущему потоку 
                        
            //если окно является дочерним то найти его родителя
            //получение дескриптора родительского окна
            if(::GetWindowLongPtr(hwnd, GWL_STYLE) & WS_CHILD) hwnd = ::GetParent(hwnd);
            //если окно является OWNED
            //получаем дескриптор окна владельца
            else hwnd = ::GetWindow(hwnd, GW_OWNER);

        //это по идее будет тот же смысл, что и GetAncestor
        //но как мне кажется более правильный
        } while(hwnd);

        //окончание поиска окон в данном потоке
        return FALSE;
    }//if(IsWindowVisible(hwnd))
    
    //достаточно получить дескриптор любого окна для того чтобы потом найти его ROOTOWNER
    //hwnd = GetAncestor(hwnd, GA_ROOTOWNER);

    //копирование полученного дескриптора по переданному из вне адресу
    //memcpy((void*)lParam, (void*)&hwnd, sizeof(HWND));

    //пускай делает перекличку до тех пор пока не найдем первого крайнего
    return TRUE;
}

https://www.cyberforum.ru/win-api/thread1989913.html